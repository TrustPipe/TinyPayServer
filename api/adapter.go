package api

import (
	"context"
	"fmt"
	"log"
	"math/big"
	"net/http"
	"strings"
	"sync"
	"tinypay-server/config"
	"tinypay-server/utils"

	"tinypay-server/client"

	"github.com/gin-gonic/gin"
)

// APIServer implements the ServerInterface generated by oapi-codegen
type APIServer struct {
	aptosClient   *client.AptosClient
	evmClients    map[string]*client.EVMClient    // Map of network name to EVM client
	solanaClients map[string]*client.SolanaClient // Map of network name to Solana client
	payerLocks    map[string]*sync.Mutex
	locksMutex    sync.RWMutex
	config        *config.Config
}

// NewAPIServer creates a new API server instance
func NewAPIServer(aptosClient *client.AptosClient, evmClients map[string]*client.EVMClient, solanaClients map[string]*client.SolanaClient, cfg *config.Config) *APIServer {
	return &APIServer{
		aptosClient:   aptosClient,
		evmClients:    evmClients,
		solanaClients: solanaClients,
		payerLocks:    make(map[string]*sync.Mutex),
		locksMutex:    sync.RWMutex{},
		config:        cfg,
	}
}

// getEVMClient returns the EVM client for the specified network
func (s *APIServer) getEVMClient(network string) *client.EVMClient {
	if s.evmClients == nil {
		return nil
	}
	return s.evmClients[network]
}

// getSolanaClient returns the Solana client for the specified network
func (s *APIServer) getSolanaClient(network string) *client.SolanaClient {
	if s.solanaClients == nil {
		return nil
	}
	return s.solanaClients[network]
}

// isNetworkAvailable checks if a network is properly configured and available
func (s *APIServer) isNetworkAvailable(network string) (bool, error) {
    switch network {
    case "aptos-testnet":
        if s.aptosClient == nil {
            return false, fmt.Errorf("aptos client not initialized")
        }
        // Check basic configuration
        if s.config.ContractAddress == "" {
            return false, fmt.Errorf("aptos contract address not configured")
        }
        return true, nil
    default:
        // Check if it's a Solana network first
        solanaClient := s.getSolanaClient(network)
        if solanaClient != nil {
            // Solana network found and initialized
            return true, nil
        }
        
        // Treat as EVM network configured via array
        evmClient := s.getEVMClient(network)
        if evmClient == nil {
            return false, fmt.Errorf("evm client not initialized for %s", network)
        }
        if netCfg := utils.GetEVMNetworkConfig(s.config, network); netCfg != nil {
            if strings.TrimSpace(netCfg.RPCURL) == "" || strings.TrimSpace(netCfg.ContractAddress) == "" || strings.TrimSpace(netCfg.PrivateKey) == "" {
                return false, fmt.Errorf("evm network %s not properly configured", network)
            }
            return true, nil
        }
        return false, fmt.Errorf("unsupported network: %s", network)
    }
}

// validateNetworkAndCurrency performs comprehensive network and currency validation
func (s *APIServer) validateNetworkAndCurrency(network, currency string) error {
    // Use the comprehensive validation from utils package (dynamic)
    if err := utils.ValidateNetworkCurrencyCombination(s.config, network, currency); err != nil {
        return err
    }

	// Check if network is available
	available, err := s.isNetworkAvailable(network)
	if !available {
		log.Printf("Network %s is not available: %v", network, err)
		return fmt.Errorf("network %s is not available: %w", network, err)
	}

    // Additional network-specific configuration validation
    switch strings.ToLower(network) {
    case "aptos-testnet":
        if currency == "USDC" && strings.TrimSpace(s.config.USDCMetadataAddress) == "" {
            return fmt.Errorf("aptos USDC metadata address not configured")
        }
    }

	return nil
}

// getDetailedValidationError returns a detailed error message for validation failures
func (s *APIServer) getDetailedValidationError(network, currency string) map[string]interface{} {
    matrix := utils.NewNetworkCurrencyValidationMatrix(s.config)

	data := map[string]interface{}{
		"error":              "Invalid network-currency combination",
		"provided_network":   network,
		"provided_currency":  currency,
		"supported_networks": matrix.GetSupportedNetworks(),
	}

	// Add supported currencies for the provided network if it exists
	if supportedCurrencies := matrix.GetSupportedCurrenciesForNetwork(network); len(supportedCurrencies) > 0 {
		data["supported_currencies_for_network"] = supportedCurrencies
	}

	// Add suggestion for default currency if network is valid
    if defaultCurrency := utils.GetDefaultCurrencyForNetwork(s.config, network); defaultCurrency != "" {
        data["suggested_currency"] = defaultCurrency
    }

	return data
}

// getPayerLock returns the mutex for a specific payer address, creating one if it doesn't exist
func (s *APIServer) getPayerLock(payerAddr string) *sync.Mutex {
	// First try to get the lock with read lock
	s.locksMutex.RLock()
	if lock, exists := s.payerLocks[payerAddr]; exists {
		s.locksMutex.RUnlock()
		return lock
	}
	s.locksMutex.RUnlock()

	// If lock doesn't exist, acquire write lock and create it
	s.locksMutex.Lock()
	defer s.locksMutex.Unlock()

	// Double-check in case another goroutine created it while we were waiting
	if lock, exists := s.payerLocks[payerAddr]; exists {
		return lock
	}

	// Create new lock for this payer
	lock := &sync.Mutex{}
	s.payerLocks[payerAddr] = lock
	return lock
}

// HealthCheck implements the health check endpoint
func (s *APIServer) HealthCheck(c *gin.Context) {
	data := map[string]interface{}{
		"status": "success",
	}

	response := CreateApiResponseWithMap(CodeServerHealthy, data)
	c.JSON(http.StatusOK, response)
}

// CreatePayment implements the payment creation endpoint
func (s *APIServer) CreatePayment(c *gin.Context) {
	var req PaymentRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		// Invalid request body format
		response := CreateApiResponseWithNullData(CodeInvalidOpt)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	// Early validation to get payer address for locking
	if req.PayerAddr == "" {
		missingFields := []string{"payer_addr"}
		data := map[string]interface{}{
			"missing_fields": missingFields,
		}
		response := CreateApiResponseWithMap(CodeMissingFields, data)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	// Acquire lock for this specific payer to prevent concurrent payments
	payerLock := s.getPayerLock(req.PayerAddr)
	payerLock.Lock()
	defer payerLock.Unlock()

	// Check for missing fields after successful JSON binding (PayerAddr already validated above)
    missingFields := []string{}
    if req.Otp == "" {
        missingFields = append(missingFields, "otp")
    }
	if req.PayeeAddr == "" {
		missingFields = append(missingFields, "payee_addr")
	}
	if req.Amount == 0 {
		missingFields = append(missingFields, "amount")
	}

	if len(missingFields) > 0 {
		data := map[string]interface{}{
			"missing_fields": missingFields,
		}
		response := CreateApiResponseWithMap(CodeMissingFields, data)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	// Handle network type - default to aptos-testnet if not specified
	network := "aptos-testnet"
	if req.Network != nil {
		network = string(*req.Network)
	}

	// Handle currency type - default based on network if not specified
	currency := "APT"
	if req.Currency != nil {
		currency = string(*req.Currency)
	} else {
		if strings.ToLower(network) == "aptos-testnet" {
			currency = "APT"
		} else if netCfg := utils.GetEVMNetworkConfig(s.config, network); netCfg != nil {
			currency = strings.ToUpper(netCfg.NativeToken.Symbol)
		}
	}

	// Validate network and currency combination with enhanced error handling
	if err := s.validateNetworkAndCurrency(network, currency); err != nil {
		log.Printf("Network/currency validation failed: %v", err)

		// Determine appropriate error code based on the error type
		errorMsg := err.Error()
		var errorCode int
		var responseData map[string]interface{}

		if strings.Contains(errorMsg, "not available") || strings.Contains(errorMsg, "not configured") {
			errorCode = CodeNetworkUnavailable
		} else if strings.Contains(errorMsg, "unsupported network") {
			errorCode = CodeInvalidOpt
			responseData = s.getDetailedValidationError(network, currency)
		} else if strings.Contains(errorMsg, "not supported on network") {
			errorCode = CodeInvalidNetworkCurrency
			responseData = s.getDetailedValidationError(network, currency)
		} else {
			errorCode = CodeNetworkConfigError
		}

		if responseData != nil {
			response := CreateApiResponseWithMap(errorCode, responseData)
			c.JSON(http.StatusBadRequest, response)
		} else {
			response := CreateApiResponseWithNullData(errorCode)
			c.JSON(http.StatusBadRequest, response)
		}
		return
	}

	var coinType string
	var err error
	switch network {
	case "aptos-testnet":
		// Get coin type from currency mapping
		coinType, err = utils.GetCoinType(s.aptosClient.GetConfig(), currency)
		if err != nil {
			log.Printf("Unsupported currency: %s", currency)
			response := CreateApiResponseWithNullData(CodeInvalidOpt)
			c.JSON(http.StatusBadRequest, response)
			return
		}
	default:
		// For EVM networks, we'll use the currency directly as the token identifier
		coinType = currency
		// Validate that we have an EVM client for this network
		evmClient := s.getEVMClient(network)
		if evmClient == nil {
			log.Printf("EVM client not initialized for network %s", network)
			response := CreateApiResponseWithNullData(CodeNetworkUnavailable)
			c.JSON(http.StatusInternalServerError, response)
			return
		}
	}

	log.Printf("Processing payment on network: %s with currency: %s, coin type: %s", network, currency, coinType)

    // Convert hex strings to bytes
    optBytes := utils.HexToASCIIBytes(req.Otp)
	log.Printf("\nAptos CLI format for otp:\n")
	fmt.Printf("u8:[")
	for i, b := range optBytes {
		if i > 0 {
			fmt.Printf(",")
		}
		fmt.Printf("%d", b)
	}
	fmt.Printf("]\n")

	// Convert amount to uint64
	amount := uint64(req.Amount)

	// Check amount validation
	if amount <= 0 {
		response := CreateApiResponseWithNullData(CodeAmountMustBePositive)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	// Compute payment hash for the transaction
	// note: 暂时不用商家自行处理 precommit
	//commitHash, err := s.aptosClient.ComputePaymentHash(req.PayerAddr, req.PayeeAddr, amount, optBytes)
	//if err != nil {
	//	log.Printf("Failed to compute payment hash: %v", err)
	//	response := CreateApiResponseWithNullData(CodeInvalidOpt)
	//	c.JSON(http.StatusBadRequest, response)
	//	return
	//}

	var txHash string
	switch network {
	case "aptos-testnet":
		// Submit the transaction with FA support
    txHash, err = s.aptosClient.CompletePaymentWithFA(optBytes, req.PayerAddr, req.PayeeAddr, amount, []byte(""), currency)
		if err != nil {
			log.Printf("Failed to complete Aptos payment: %v", err)
			// todo:
			// Randomly return one of the validation error codes (2000-2003)
			errorCodes := []int{CodeAmountMustBePositive, CodeAmountExceedsLimit, CodeInsufficientBalance, CodeInvalidOpt}
			randomCode := errorCodes[len(err.Error())%len(errorCodes)]
			response := CreateApiResponseWithNullData(randomCode)
			c.JSON(http.StatusBadRequest, response)
			return
		}
	default:
		// Check if it's a Solana network first
		solanaClient := s.getSolanaClient(network)
		if solanaClient != nil {
			// Process Solana payment
			payerPubkey, err := utils.ParseSolanaPublicKey(req.PayerAddr)
			if err != nil {
				log.Printf("Invalid Solana payer address: %v", err)
				response := CreateApiResponseWithNullData(CodeInvalidOpt)
				c.JSON(http.StatusBadRequest, response)
				return
			}

			recipientPubkey, err := utils.ParseSolanaPublicKey(req.PayeeAddr)
			if err != nil {
				log.Printf("Invalid Solana recipient address: %v", err)
				response := CreateApiResponseWithNullData(CodeInvalidOpt)
				c.JSON(http.StatusBadRequest, response)
				return
			}

			sig, err := solanaClient.CompletePayment(context.Background(), payerPubkey, recipientPubkey, req.Otp, amount)
			if err != nil {
				log.Printf("Failed to complete Solana payment on %s: %v", network, err)
				errorMsg := strings.ToLower(err.Error())
				var errorCode int

				if strings.Contains(errorMsg, "insufficient") || strings.Contains(errorMsg, "balance") {
					errorCode = CodeInsufficientBalance
				} else if strings.Contains(errorMsg, "limit") || strings.Contains(errorMsg, "exceed") {
					errorCode = CodeAmountExceedsLimit
				} else if strings.Contains(errorMsg, "connection") || strings.Contains(errorMsg, "rpc") {
					errorCode = CodeNetworkConnectionError
				} else {
					errorCode = CodeInvalidOpt
				}

				response := CreateApiResponseWithNullData(errorCode)
				c.JSON(http.StatusBadRequest, response)
				return
			}
			txHash = sig.String()
		} else {
			// Get the network-specific EVM client
			evmClient := s.getEVMClient(network)
			if evmClient == nil {
				log.Printf("EVM client not initialized for network %s", network)
				response := CreateApiResponseWithNullData(CodeNetworkUnavailable)
				c.JSON(http.StatusInternalServerError, response)
				return
			}

		// For EVM networks, we need to convert the amount to *big.Int
		amountBig := new(big.Int).SetUint64(amount)

		// For EVM, we'll use a fixed commit hash for now (32 bytes of zeros)
		// In a real implementation, this would need to be computed properly
		commitHash := "0x0000000000000000000000000000000000000000000000000000000000000000"

		// Resolve token address dynamically from configuration
		tokenAddress, err := utils.GetEVMTokenAddressByNetwork(evmClient.GetConfig(), currency, network)
		if err != nil || strings.TrimSpace(tokenAddress) == "" {
			log.Printf("Invalid currency %s for network %s: %v", currency, network, err)
			response := CreateApiResponseWithNullData(CodeInvalidNetworkCurrency)
			c.JSON(http.StatusBadRequest, response)
			return
		}

		if tokenAddress == "" {
			log.Printf("Invalid currency %s for network %s", currency, network)
			response := CreateApiResponseWithNullData(CodeInvalidNetworkCurrency)
			c.JSON(http.StatusBadRequest, response)
			return
		}

		// Call the network-specific EVM client's CompletePayment method with enhanced error handling
    tx, err := evmClient.CompletePayment(context.Background(), tokenAddress, req.PayerAddr, req.PayeeAddr, amountBig, req.Otp, commitHash)
		if err != nil {
			log.Printf("Failed to complete EVM payment on %s: %v", network, err)

			// Enhanced error handling based on error type
			errorMsg := strings.ToLower(err.Error())
			var errorCode int

			if strings.Contains(errorMsg, "insufficient") || strings.Contains(errorMsg, "balance") {
				errorCode = CodeInsufficientBalance
			} else if strings.Contains(errorMsg, "amount") && (strings.Contains(errorMsg, "invalid") || strings.Contains(errorMsg, "zero")) {
				errorCode = CodeAmountMustBePositive
			} else if strings.Contains(errorMsg, "limit") || strings.Contains(errorMsg, "exceed") {
				errorCode = CodeAmountExceedsLimit
			} else if strings.Contains(errorMsg, "connection") || strings.Contains(errorMsg, "rpc") || strings.Contains(errorMsg, "network") {
				errorCode = CodeNetworkConnectionError
			} else if strings.Contains(errorMsg, "config") || strings.Contains(errorMsg, "address") {
				errorCode = CodeNetworkConfigError
			} else {
				errorCode = CodeInvalidOpt
			}

			response := CreateApiResponseWithNullData(errorCode)
			c.JSON(http.StatusBadRequest, response)
			return
		}
		txHash = tx.Hex()
		}
	}

	data := map[string]interface{}{
		"status":           "submitted",
		"transaction_hash": txHash,
		"currency":         currency,
		"network":          network,
		"coin_type":        coinType,
	}
	response := CreateApiResponseWithMap(CodeTransactionCreated, data)
	c.JSON(http.StatusOK, response)
}

// GetTransactionStatus implements the transaction status query endpoint
func (s *APIServer) GetTransactionStatus(c *gin.Context, transactionHash string, params GetTransactionStatusParams) {
	if transactionHash == "" {
		response := CreateApiResponseWithNullData(CodeTransactionNotFound)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	// Determine network from parsed params (OpenAPI), fallback to query param; default to aptos-testnet
	network := "aptos-testnet"
	if params.Network != nil {
		network = string(*params.Network)
	} else {
		if qn := c.Query("network"); qn != "" {
			network = qn
		}
	}

	switch network {
	case "aptos-testnet":
		// Get detailed transaction information from Aptos
		txInfo, err := s.aptosClient.GetTransactionDetails(transactionHash)
		if err != nil {
			response := CreateApiResponseWithNullData(CodeTransactionNotFound)
			c.JSON(http.StatusNotFound, response)
			return
		}

		if !txInfo.Confirmed {
			data := map[string]interface{}{
				"status":  "pending",
				"network": network,
			}
			response := CreateApiResponseWithMap(CodeTransactionPending, data)
			c.JSON(http.StatusOK, response)
			return
		}

		if txInfo.Success {
			data := map[string]interface{}{
				"status":          "confirmed",
				"received_amount": txInfo.Amount,
				"currency":        txInfo.CoinType,
				"network":         network,
			}
			response := CreateApiResponseWithMap(CodeTransactionConfirmed, data)
			c.JSON(http.StatusOK, response)
		} else {
			data := map[string]interface{}{
				"status":  "failed",
				"error":   txInfo.Error,
				"network": network,
			}
			response := CreateApiResponseWithMap(CodeTransactionConfirmed, data)
			c.JSON(http.StatusOK, response)
		}
	default:
		// Check network availability first
		if available, err := s.isNetworkAvailable(network); !available {
			log.Printf("Network %s not available for transaction status query: %v", network, err)
			response := CreateApiResponseWithNullData(CodeNetworkUnavailable)
			c.JSON(http.StatusServiceUnavailable, response)
			return
		}

		// Check if it's a Solana network first
		solanaClient := s.getSolanaClient(network)
		if solanaClient != nil {
			// Fetch Solana transaction details
			txInfo, err := solanaClient.GetTransactionDetails(c.Request.Context(), transactionHash)
			if err != nil {
				log.Printf("Failed to get Solana transaction details for %s on %s: %v", transactionHash, network, err)
				errorMsg := strings.ToLower(err.Error())
				var errorCode int

				if strings.Contains(errorMsg, "not found") {
					errorCode = CodeTransactionNotFound
				} else if strings.Contains(errorMsg, "connection") || strings.Contains(errorMsg, "rpc") {
					errorCode = CodeNetworkConnectionError
				} else {
					errorCode = CodeTransactionNotFound
				}

				response := CreateApiResponseWithNullData(errorCode)
				c.JSON(http.StatusNotFound, response)
				return
			}

			if !txInfo.Confirmed {
				data := map[string]interface{}{
					"status":  "pending",
					"network": network,
				}
				response := CreateApiResponseWithMap(CodeTransactionPending, data)
				c.JSON(http.StatusOK, response)
				return
			}

			if txInfo.Success {
				data := map[string]interface{}{
					"status":          "confirmed",
					"received_amount": txInfo.Amount,
					"currency":        txInfo.CoinType,
					"network":         network,
				}
				response := CreateApiResponseWithMap(CodeTransactionConfirmed, data)
				c.JSON(http.StatusOK, response)
			} else {
				data := map[string]interface{}{
					"status":  "failed",
					"error":   txInfo.Error,
					"network": network,
				}
				response := CreateApiResponseWithMap(CodeTransactionConfirmed, data)
				c.JSON(http.StatusOK, response)
			}
			return
		}

		// Get the network-specific EVM client
		evmClient := s.getEVMClient(network)
		if evmClient == nil {
			log.Printf("EVM client not initialized for network %s", network)
			response := CreateApiResponseWithNullData(CodeNetworkUnavailable)
			c.JSON(http.StatusInternalServerError, response)
			return
		}

		// Fetch EVM transaction details with enhanced error handling
		txInfo, err := evmClient.GetTransactionDetails(c.Request.Context(), transactionHash)
		if err != nil {
			log.Printf("Failed to get transaction details for %s on %s: %v", transactionHash, network, err)

			// Enhanced error handling based on error type
			errorMsg := strings.ToLower(err.Error())
			var errorCode int

			if strings.Contains(errorMsg, "not found") {
				errorCode = CodeTransactionNotFound
			} else if strings.Contains(errorMsg, "connection") || strings.Contains(errorMsg, "rpc") || strings.Contains(errorMsg, "network") {
				errorCode = CodeNetworkConnectionError
			} else {
				errorCode = CodeTransactionNotFound
			}

			response := CreateApiResponseWithNullData(errorCode)
			c.JSON(http.StatusNotFound, response)
			return
		}
		if !txInfo.Confirmed {
			data := map[string]interface{}{
				"status":  "pending",
				"network": network,
			}
			response := CreateApiResponseWithMap(CodeTransactionPending, data)
			c.JSON(http.StatusOK, response)
			return
		}
		if txInfo.Success {
			// Determine currency from token address based on network
			var currency string
			if txInfo.TokenAddress != "" && txInfo.TokenAddress != "0x0000000000000000000000000000000000000000" {
				// Try to get currency from token address using network-specific mapping
				currency = utils.GetCurrencyFromEVMTokenAddressByNetwork(evmClient.GetConfig(), txInfo.TokenAddress, network)
				if currency == "UNKNOWN" {
					// Fallback to network's native currency if mapping fails
					if netCfg := utils.GetEVMNetworkConfig(evmClient.GetConfig(), network); netCfg != nil {
						currency = strings.ToUpper(netCfg.NativeToken.Symbol)
					} else {
						currency = "UNKNOWN"
					}
				}
			} else {
				// Zero address means native token
				if netCfg := utils.GetEVMNetworkConfig(evmClient.GetConfig(), network); netCfg != nil {
					currency = strings.ToUpper(netCfg.NativeToken.Symbol)
				} else {
					currency = "UNKNOWN"
				}
			}

			data := map[string]interface{}{
				"status":          "confirmed",
				"received_amount": txInfo.Amount,
				"currency":        currency,
				"network":         network,
			}
			response := CreateApiResponseWithMap(CodeTransactionConfirmed, data)
			c.JSON(http.StatusOK, response)
		} else {
			data := map[string]interface{}{
				"status":  "failed",
				"error":   txInfo.Error,
				"network": network,
			}
			response := CreateApiResponseWithMap(CodeTransactionConfirmed, data)
			c.JSON(http.StatusOK, response)
		}
    }
}

// GetUserLimits implements the GET /api/users/{user_address}/limits endpoint
func (s *APIServer) GetUserLimits(c *gin.Context, userAddress string, params GetUserLimitsParams) {
	log.Printf("Getting user limits for address: %s", userAddress)

	// Validate user address format
	if userAddress == "" {
		response := CreateApiResponseWithNullData(CodeInvalidOpt)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	// Determine network from parsed params (OpenAPI), fallback to query param; default to aptos-testnet
	network := "aptos-testnet"
	if params.Network != nil {
		network = string(*params.Network)
	} else {
		if qn := c.Query("network"); qn != "" {
			network = qn
		}
	}

	switch network {
	case "aptos-testnet":
		userLimits, err := s.aptosClient.GetUserLimits(userAddress)
		if err != nil {
			log.Printf("Failed to get user limits: %v", err)
			response := CreateApiResponseWithNullData(CodeInvalidOpt)
			c.JSON(http.StatusBadRequest, response)
			return
		}
		data := map[string]interface{}{
			"user_limits": userLimits,
			"network":     network,
		}
		response := CreateApiResponseWithMap(CodeServerHealthy, data)
		c.JSON(http.StatusOK, response)
	default:
		// Check network availability first
		if available, err := s.isNetworkAvailable(network); !available {
			log.Printf("Network %s not available for user limits query: %v", network, err)
			response := CreateApiResponseWithNullData(CodeNetworkUnavailable)
			c.JSON(http.StatusServiceUnavailable, response)
			return
		}

		// Check if it's a Solana network first
		solanaClient := s.getSolanaClient(network)
		if solanaClient != nil {
			// Parse Solana public key
			userPubkey, err := utils.ParseSolanaPublicKey(userAddress)
			if err != nil {
				log.Printf("Invalid Solana user address: %v", err)
				response := CreateApiResponseWithNullData(CodeInvalidOpt)
				c.JSON(http.StatusBadRequest, response)
				return
			}

			userLimits, err := solanaClient.GetUserLimits(c.Request.Context(), userPubkey)
			if err != nil {
				log.Printf("Failed to get Solana user limits for network %s: %v", network, err)
				errorMsg := strings.ToLower(err.Error())
				var errorCode int

				if strings.Contains(errorMsg, "connection") || strings.Contains(errorMsg, "rpc") {
					errorCode = CodeNetworkConnectionError
				} else if strings.Contains(errorMsg, "not found") {
					errorCode = CodeInvalidOpt
				} else {
					errorCode = CodeInvalidOpt
				}

				response := CreateApiResponseWithNullData(errorCode)
				c.JSON(http.StatusBadRequest, response)
				return
			}

			data := map[string]interface{}{
				"user_limits": userLimits,
				"network":     network,
			}
			response := CreateApiResponseWithMap(CodeServerHealthy, data)
			c.JSON(http.StatusOK, response)
			return
		}

		// Get the network-specific EVM client
		evmClient := s.getEVMClient(network)
		if evmClient == nil {
			log.Printf("EVM client not initialized for network %s", network)
			response := CreateApiResponseWithNullData(CodeNetworkUnavailable)
			c.JSON(http.StatusInternalServerError, response)
			return
		}

		userLimits, err := evmClient.GetUserLimits(c.Request.Context(), userAddress)
		if err != nil {
			log.Printf("Failed to get EVM user limits for network %s: %v", network, err)

			// Enhanced error handling based on error type
			errorMsg := strings.ToLower(err.Error())
			var errorCode int

			if strings.Contains(errorMsg, "connection") || strings.Contains(errorMsg, "rpc") || strings.Contains(errorMsg, "network") {
				errorCode = CodeNetworkConnectionError
			} else if strings.Contains(errorMsg, "config") || strings.Contains(errorMsg, "address") {
				errorCode = CodeNetworkConfigError
			} else {
				errorCode = CodeInvalidOpt
			}

			response := CreateApiResponseWithNullData(errorCode)
			c.JSON(http.StatusBadRequest, response)
			return
		}
		data := map[string]interface{}{
			"user_limits": userLimits,
			"network":     network,
		}
		response := CreateApiResponseWithMap(CodeServerHealthy, data)
		c.JSON(http.StatusOK, response)
    }
}
