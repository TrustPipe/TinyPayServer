package api

import (
	"context"
	"fmt"
	"log"
	"math/big"
	"net/http"
	"sync"
	"tinypay-server/utils"

	"tinypay-server/client"

	"github.com/gin-gonic/gin"
)

// APIServer implements the ServerInterface generated by oapi-codegen
type APIServer struct {
	aptosClient *client.AptosClient
	evmClient   *client.EVMClient
	payerLocks  map[string]*sync.Mutex
	locksMutex  sync.RWMutex
}

// NewAPIServer creates a new API server instance
func NewAPIServer(aptosClient *client.AptosClient, evmClient *client.EVMClient) *APIServer {
	return &APIServer{
		aptosClient: aptosClient,
		evmClient:   evmClient,
		payerLocks:  make(map[string]*sync.Mutex),
		locksMutex:  sync.RWMutex{},
	}
}

// getPayerLock returns the mutex for a specific payer address, creating one if it doesn't exist
func (s *APIServer) getPayerLock(payerAddr string) *sync.Mutex {
	// First try to get the lock with read lock
	s.locksMutex.RLock()
	if lock, exists := s.payerLocks[payerAddr]; exists {
		s.locksMutex.RUnlock()
		return lock
	}
	s.locksMutex.RUnlock()

	// If lock doesn't exist, acquire write lock and create it
	s.locksMutex.Lock()
	defer s.locksMutex.Unlock()

	// Double-check in case another goroutine created it while we were waiting
	if lock, exists := s.payerLocks[payerAddr]; exists {
		return lock
	}

	// Create new lock for this payer
	lock := &sync.Mutex{}
	s.payerLocks[payerAddr] = lock
	return lock
}

// HealthCheck implements the health check endpoint
func (s *APIServer) HealthCheck(c *gin.Context) {
	data := map[string]interface{}{
		"status": "success",
	}

	response := CreateApiResponseWithMap(CodeServerHealthy, data)
	c.JSON(http.StatusOK, response)
}

// CreatePayment implements the payment creation endpoint
func (s *APIServer) CreatePayment(c *gin.Context) {
	var req PaymentRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		// Invalid request body format
		response := CreateApiResponseWithNullData(CodeInvalidOpt)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	// Early validation to get payer address for locking
	if req.PayerAddr == "" {
		missingFields := []string{"payer_addr"}
		data := map[string]interface{}{
			"missing_fields": missingFields,
		}
		response := CreateApiResponseWithMap(CodeMissingFields, data)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	// Acquire lock for this specific payer to prevent concurrent payments
	payerLock := s.getPayerLock(req.PayerAddr)
	payerLock.Lock()
	defer payerLock.Unlock()

	// Check for missing fields after successful JSON binding (PayerAddr already validated above)
	missingFields := []string{}
	if req.Opt == "" {
		missingFields = append(missingFields, "otp")
	}
	if req.PayeeAddr == "" {
		missingFields = append(missingFields, "payee_addr")
	}
	if req.Amount == 0 {
		missingFields = append(missingFields, "amount")
	}

	if len(missingFields) > 0 {
		data := map[string]interface{}{
			"missing_fields": missingFields,
		}
		response := CreateApiResponseWithMap(CodeMissingFields, data)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	// Handle network type - default to aptos-testnet if not specified
	network := "aptos-testnet"
	if req.Network != nil {
		network = string(*req.Network)
	}

	// Handle currency type - default to APT for aptos-testnet and ETH for eth-sepolia if not specified
	currency := "APT"
	if req.Currency != nil {
		currency = string(*req.Currency)
	} else if network == "eth-sepolia" {
		currency = "ETH"
	}

	if (network == "aptos-testnet" && currency == "ETH") || (network == "eth-sepolia" && currency == "APT") {
		log.Printf("Invalid currency %s for network %s", currency, network)
		response := CreateApiResponseWithNullData(CodeInvalidCurrency)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	var coinType string
	var err error
	switch network {
	case "aptos-testnet":
		// Get coin type from currency mapping
		coinType, err = utils.GetCoinType(s.aptosClient.GetConfig(), currency)
		if err != nil {
			log.Printf("Unsupported currency: %s", currency)
			response := CreateApiResponseWithNullData(CodeInvalidOpt)
			c.JSON(http.StatusBadRequest, response)
			return
		}
	case "eth-sepolia":
		// For EVM, we'll use the currency directly as the token identifier
		coinType = currency
		// Validate that we have an EVM client
		if s.evmClient == nil {
			log.Printf("EVM client not initialized")
			response := CreateApiResponseWithNullData(CodeInvalidOpt)
			c.JSON(http.StatusInternalServerError, response)
			return
		}
	default:
		log.Printf("Unsupported network: %s", network)
		response := CreateApiResponseWithNullData(CodeInvalidOpt)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	log.Printf("Processing payment on network: %s with currency: %s, coin type: %s", network, currency, coinType)

	// Convert hex strings to bytes
	optBytes := utils.HexToASCIIBytes(req.Opt)
	log.Printf("\nAptos CLI format for otp:\n")
	fmt.Printf("u8:[")
	for i, b := range optBytes {
		if i > 0 {
			fmt.Printf(",")
		}
		fmt.Printf("%d", b)
	}
	fmt.Printf("]\n")

	// Convert amount to uint64
	amount := uint64(req.Amount)

	// Check amount validation
	if amount <= 0 {
		response := CreateApiResponseWithNullData(CodeAmountMustBePositive)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	// Compute payment hash for the transaction
	// note: 暂时不用商家自行处理 precommit
	//commitHash, err := s.aptosClient.ComputePaymentHash(req.PayerAddr, req.PayeeAddr, amount, optBytes)
	//if err != nil {
	//	log.Printf("Failed to compute payment hash: %v", err)
	//	response := CreateApiResponseWithNullData(CodeInvalidOpt)
	//	c.JSON(http.StatusBadRequest, response)
	//	return
	//}

	var txHash string
	switch network {
	case "aptos-testnet":
		// Submit the transaction with FA support
		txHash, err = s.aptosClient.CompletePaymentWithFA(optBytes, req.PayerAddr, req.PayeeAddr, amount, []byte(""), currency)
		if err != nil {
			log.Printf("Failed to complete Aptos payment: %v", err)
			// todo:
			// Randomly return one of the validation error codes (2000-2003)
			errorCodes := []int{CodeAmountMustBePositive, CodeAmountExceedsLimit, CodeInsufficientBalance, CodeInvalidOpt}
			randomCode := errorCodes[len(err.Error())%len(errorCodes)]
			response := CreateApiResponseWithNullData(randomCode)
			c.JSON(http.StatusBadRequest, response)
			return
		}
	case "eth-sepolia":
		// For EVM, we need to convert the amount to *big.Int
		amountBig := new(big.Int).SetUint64(amount)

		// For EVM, we'll use a fixed commit hash for now (32 bytes of zeros)
		// In a real implementation, this would need to be computed properly
		commitHash := "0x0000000000000000000000000000000000000000000000000000000000000000"

		var tokenAddress string
		if currency == "ETH" {
			tokenAddress = "0x0000000000000000000000000000000000000000"
		} else {
			log.Printf("Invalid currency %s for network %s", currency, network)
			response := CreateApiResponseWithNullData(CodeInvalidCurrency)
			c.JSON(http.StatusBadRequest, response)
			return
		}

		// Call the EVM client's CompletePayment method
		tx, err := s.evmClient.CompletePayment(context.Background(), tokenAddress, req.PayerAddr, req.PayeeAddr, amountBig, req.Opt, commitHash)
		if err != nil {
			log.Printf("Failed to complete EVM payment: %v", err)
			// todo:
			// Randomly return one of the validation error codes (2000-2003)
			errorCodes := []int{CodeAmountMustBePositive, CodeAmountExceedsLimit, CodeInsufficientBalance, CodeInvalidOpt}
			randomCode := errorCodes[len(err.Error())%len(errorCodes)]
			response := CreateApiResponseWithNullData(randomCode)
			c.JSON(http.StatusBadRequest, response)
			return
		}
		txHash = tx.Hex()
	}

	data := map[string]interface{}{
		"status":           "submitted",
		"transaction_hash": txHash,
		"currency":         currency,
		"network":          network,
		"coin_type":        coinType,
	}
	response := CreateApiResponseWithMap(CodeTransactionCreated, data)
	c.JSON(http.StatusOK, response)
}

// GetTransactionStatus implements the transaction status query endpoint
func (s *APIServer) GetTransactionStatus(c *gin.Context, transactionHash string, params GetTransactionStatusParams) {
	if transactionHash == "" {
		response := CreateApiResponseWithNullData(CodeTransactionNotFound)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	// Determine network from parsed params (OpenAPI), fallback to query param; default to aptos-testnet
	network := "aptos-testnet"
	if params.Network != nil {
		network = string(*params.Network)
	} else {
		if qn := c.Query("network"); qn != "" {
			network = qn
		}
	}

	switch network {
	case "aptos-testnet":
		// Get detailed transaction information from Aptos
		txInfo, err := s.aptosClient.GetTransactionDetails(transactionHash)
		if err != nil {
			response := CreateApiResponseWithNullData(CodeTransactionNotFound)
			c.JSON(http.StatusNotFound, response)
			return
		}

		if !txInfo.Confirmed {
			data := map[string]interface{}{
				"status":  "pending",
				"network": network,
			}
			response := CreateApiResponseWithMap(CodeTransactionPending, data)
			c.JSON(http.StatusOK, response)
			return
		}

		if txInfo.Success {
			data := map[string]interface{}{
				"status":          "confirmed",
				"received_amount": txInfo.Amount,
				"currency":        txInfo.CoinType,
				"network":         network,
			}
			response := CreateApiResponseWithMap(CodeTransactionConfirmed, data)
			c.JSON(http.StatusOK, response)
		} else {
			data := map[string]interface{}{
				"status":  "failed",
				"error":   txInfo.Error,
				"network": network,
			}
			response := CreateApiResponseWithMap(CodeTransactionConfirmed, data)
			c.JSON(http.StatusOK, response)
		}
	case "eth-sepolia":
		if s.evmClient == nil {
			response := CreateApiResponseWithNullData(CodeInvalidOpt)
			c.JSON(http.StatusInternalServerError, response)
			return
		}
		// Fetch EVM transaction details
		txInfo, err := s.evmClient.GetTransactionDetails(c.Request.Context(), transactionHash)
		if err != nil {
			response := CreateApiResponseWithNullData(CodeTransactionNotFound)
			c.JSON(http.StatusNotFound, response)
			return
		}
		if !txInfo.Confirmed {
			data := map[string]interface{}{
				"status":  "pending",
				"network": network,
			}
			response := CreateApiResponseWithMap(CodeTransactionPending, data)
			c.JSON(http.StatusOK, response)
			return
		}
		if txInfo.Success {
			data := map[string]interface{}{
				"status":          "confirmed",
				"received_amount": txInfo.Amount,
				"currency":        "ETH",
				"network":         network,
			}
			response := CreateApiResponseWithMap(CodeTransactionConfirmed, data)
			c.JSON(http.StatusOK, response)
		} else {
			data := map[string]interface{}{
				"status":  "failed",
				"error":   txInfo.Error,
				"network": network,
			}
			response := CreateApiResponseWithMap(CodeTransactionConfirmed, data)
			c.JSON(http.StatusOK, response)
		}
	default:
		response := CreateApiResponseWithNullData(CodeInvalidOpt)
		c.JSON(http.StatusBadRequest, response)
	}
}

// GetUserLimits implements the GET /api/users/{user_address}/limits endpoint
func (s *APIServer) GetUserLimits(c *gin.Context, userAddress string, params GetUserLimitsParams) {
	log.Printf("Getting user limits for address: %s", userAddress)

	// Validate user address format
	if userAddress == "" {
		response := CreateApiResponseWithNullData(CodeInvalidOpt)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	// Determine network from parsed params (OpenAPI), fallback to query param; default to aptos-testnet
	network := "aptos-testnet"
	if params.Network != nil {
		network = string(*params.Network)
	} else {
		if qn := c.Query("network"); qn != "" {
			network = qn
		}
	}

	switch network {
	case "aptos-testnet":
		userLimits, err := s.aptosClient.GetUserLimits(userAddress)
		if err != nil {
			log.Printf("Failed to get user limits: %v", err)
			response := CreateApiResponseWithNullData(CodeInvalidOpt)
			c.JSON(http.StatusBadRequest, response)
			return
		}
		data := map[string]interface{}{
			"user_limits": userLimits,
			"network":     network,
		}
		response := CreateApiResponseWithMap(CodeServerHealthy, data)
		c.JSON(http.StatusOK, response)
	case "eth-sepolia":
		if s.evmClient == nil {
			response := CreateApiResponseWithNullData(CodeInvalidOpt)
			c.JSON(http.StatusInternalServerError, response)
			return
		}
		userLimits, err := s.evmClient.GetUserLimits(c.Request.Context(), userAddress)
		if err != nil {
			log.Printf("Failed to get EVM user limits: %v", err)
			response := CreateApiResponseWithNullData(CodeInvalidOpt)
			c.JSON(http.StatusBadRequest, response)
			return
		}
		data := map[string]interface{}{
			"user_limits": userLimits,
			"network":     network,
		}
		response := CreateApiResponseWithMap(CodeServerHealthy, data)
		c.JSON(http.StatusOK, response)
	default:
		response := CreateApiResponseWithNullData(CodeInvalidOpt)
		c.JSON(http.StatusBadRequest, response)
	}
}
