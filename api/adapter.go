package api

import (
	"fmt"
	"log"
	"net/http"
	"strconv"
	"tinypay-server/utils"

	"tinypay-server/client"

	"github.com/gin-gonic/gin"
)

// APIServer implements the ServerInterface generated by oapi-codegen
type APIServer struct {
	aptosClient *client.AptosClient
}

// NewAPIServer creates a new API server instance
func NewAPIServer(aptosClient *client.AptosClient) *APIServer {
	return &APIServer{
		aptosClient: aptosClient,
	}
}

// HealthCheck implements the health check endpoint
func (s *APIServer) HealthCheck(c *gin.Context) {
	data := map[string]interface{}{
		"status": "success",
	}

	response := CreateApiResponseWithMap(CodeServerHealthy, data)
	c.JSON(http.StatusOK, response)
}

// CreatePayment implements the payment creation endpoint
func (s *APIServer) CreatePayment(c *gin.Context) {
	var req PaymentRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		// Invalid request body format
		response := CreateApiResponseWithNullData(CodeInvalidOpt)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	// Check for missing fields after successful JSON binding
	missingFields := []string{}
	if req.PayerAddr == "" {
		missingFields = append(missingFields, "payer_addr")
	}
	if req.Opt == "" {
		missingFields = append(missingFields, "opt")
	}
	if req.PayeeAddr == "" {
		missingFields = append(missingFields, "payee_addr")
	}
	if req.Amount == 0 {
		missingFields = append(missingFields, "amount")
	}

	if len(missingFields) > 0 {
		data := map[string]interface{}{
			"missing_fields": missingFields,
		}
		response := CreateApiResponseWithMap(CodeMissingFields, data)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	// Convert hex strings to bytes
	optBytes := utils.HexToASCIIBytes(req.Opt)
	log.Printf("\nAptos CLI format for opt:\n")
	fmt.Printf("u8:[")
	for i, b := range optBytes {
		if i > 0 {
			fmt.Printf(",")
		}
		fmt.Printf("%d", b)
	}
	fmt.Printf("]\n")

	// Convert amount to uint64
	amount := uint64(req.Amount)

	// Check amount validation
	if amount <= 0 {
		response := CreateApiResponseWithNullData(CodeAmountMustBePositive)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	// Simulate the transaction first
	_, _, err := s.aptosClient.SimulatePayment(optBytes, req.PayerAddr, req.PayeeAddr, amount)
	if err != nil {
		// todo:
		// Randomly return one of the validation error codes (2000-2003)
		errorCodes := []int{CodeAmountMustBePositive, CodeAmountExceedsLimit, CodeInsufficientBalance, CodeInvalidOpt}
		randomCode := errorCodes[len(err.Error())%len(errorCodes)]
		response := CreateApiResponseWithNullData(randomCode)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	// Submit the transaction
	txHash, err := s.aptosClient.SubmitPayment(optBytes, req.PayerAddr, req.PayeeAddr, amount)
	if err != nil {
		// todo:
		// Randomly return one of the validation error codes (2000-2003)
		errorCodes := []int{CodeAmountMustBePositive, CodeAmountExceedsLimit, CodeInsufficientBalance, CodeInvalidOpt}
		randomCode := errorCodes[len(err.Error())%len(errorCodes)]
		response := CreateApiResponseWithNullData(randomCode)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	data := map[string]interface{}{
		"status":           "submitted",
		"transaction_hash": txHash,
	}
	response := CreateApiResponseWithMap(CodeTransactionCreated, data)
	c.JSON(http.StatusOK, response)
}

// GetTransactionStatus implements the transaction status query endpoint
func (s *APIServer) GetTransactionStatus(c *gin.Context, transactionHash string) {
	if transactionHash == "" {
		response := CreateApiResponseWithNullData(CodeTransactionNotFound)
		c.JSON(http.StatusBadRequest, response)
		return
	}

	// Get detailed transaction information
	txInfo, err := s.aptosClient.GetTransactionDetails(transactionHash)
	if err != nil {
		response := CreateApiResponseWithNullData(CodeTransactionNotFound)
		c.JSON(http.StatusNotFound, response)
		return
	}

	if !txInfo.Confirmed {
		data := map[string]interface{}{
			"status": "pending",
		}
		response := CreateApiResponseWithMap(CodeTransactionPending, data)
		c.JSON(http.StatusOK, response)
		return
	}

	if txInfo.Success {
		// Convert amount from octas to APT (1 APT = 100,000,000 octas)
		amountInAPT := float64(txInfo.Amount) / 100000000.0
		data := map[string]interface{}{
			"status":          "confirmed",
			"received_amount": strconv.FormatFloat(amountInAPT, 'f', 8, 64),
			"currency":        "APT",
		}
		response := CreateApiResponseWithMap(CodeTransactionConfirmed, data)
		c.JSON(http.StatusOK, response)
	} else {
		data := map[string]interface{}{
			"status": "failed",
			"error":  txInfo.Error,
		}
		response := CreateApiResponseWithMap(CodeTransactionConfirmed, data)
		c.JSON(http.StatusOK, response)
	}
}
